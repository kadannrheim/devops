



----
Команды для *UNIX систем на примере Ubuntu 20.04
# Вводная
* 3 состояния:
  * Зафиксированный (commited) - файл уже сохранён в вашей локальной базе
  * Измененный (modified) - файлы, которые поменялись, но ещё не были зафиксированы
  * Подготовленный (staged) - изменённые файлы, отмеченные для включения в следующий коммит.
  * Автор – это человек, изначально сделавший работу. 
  * Коммитер – это человек, который последним применил эту работу.
  * Другими словами, если вы создадите патч для какого-то проекта, а один из основных членов команды этого проекта применит этот патч, вы оба получите статус участника – вы как автор и основной член команды как коммитер. 

# Установка git
```
sudo apt install git
git --version
```
После того как установка Git Ubuntu будет завершена одним из выше перечисленных способов, вам нужно еще кое-что сделать перед тем, как вы сможете полноценно работать. Вам нужно идентифицировать себя указав имя пользователя и адрес электронной почты.
Самый простой способ это сделать - с помощью команды git config. Git использует имя пользователя и Email при каждом коммите, так что задавать их обязательно. Для этого выполните команды:

`git config --global user.name "kadannrheim"`
`git config --global user.email "kadannr@gmail.com"`
`git config --global core.editor emacs` -установить редактор на умолчанию

или
тоже самое в конфигурационном файле `nano ~/.gitconfig`
`git config --list` -просмотр установленных параметров

# Команды git
- `git config --list --show-origin` -Посмотреть все настройки и где они заданы
- `git config --global core.editor vim` -Установить отличный от стандартного редактор
- `git help (команда)` -справка
- `git (команда) --help` -справка
- `man git-(команда)` -справка
- `git init` -создать в текущей директории новую поддиректорию с именем .git
- `git add *` - добавить под версионный контроль существующие файлы 
или
- `git add (созданный файл)` -аналог предыдущей команды
- `git commit -m "first commit"` - выполнить коммит
- `git clone https://github.com/kadannrheim/devops-netology.git` -получить копию существующего репозитория
- `git diff` - показывает что изменили, но пока непроиндексировали
- `git diff --staged` - сравнивает проиндексированные измененияс последним коммитом
- `git diff --staged`  и `git diff --cached` - синонимы
- `git difftool` - чтобы использовать графическую утилиту
- `git commit -m "add readme"` - быстрый способсоздать коммит
- `git commit -v` - добавить в комментарий коммитаdiff
- `git rm (файл)` -удалить
- `git rm -а (файл)` -удалить если уже проиндексирован
- `git rm --cached (файл))`  - оставить файл на жесткомдиске, но перестать отслеживать
- Для перемещения файлов необходимо также сообщить об этом гиту, а не просто переместить файлы в рабочем каталоге:
  - `git mv README.md README$`
  - `git status`
- `git log` -история
-  `git log --patch -1` -Полезным аргументом является --patch, который показывает разницу (выводит патч), внесенную в каждый коммит. Вы можете ограничить количество записей в выводе команды; используйте параметр -1 для вывода только одной записи.
-  ` git log --stat -2` -Опция --stat отображает аналогичную информацию, но содержит разницу для каждой записи. Удобно использовать для код ревью или быстрого просмотра серии 
-  ` git log --pretty=oneline` - опция меняет формат вывода. 
-  ` git log --pretty=format:"%h - %an, %ar : %s"` - опция меняет формат вывода. 
   -  Опции форматирования:
      -  9%H    Хеш коммита
      -  %h    Сокращенный хеш коммита
      -  %T    Хеш дерева
      -  %t     Сокращенный хеш дерева
      -  %P    Хеш родителей
      -  %p    Сокращенный хеш родителей
      -  %an  Имя автора
      -  %ae  Электронная почта автора
      -  %ad  Дата автора (формат даты можно задать опцией --date=option)
      -  %ar   Относительная дата автора
      -  %cn  Имя коммитера
      -  %ce  Электронная почта коммитера
      -  %cd  Дата коммитера
      -  %cr   Относительн

# Подсветка ветки Git в строке терминала
В файле $/.bashrc в домашней директории надо вствавить:
```
PS1='\[\033[0;32m\]\[\033[0m\033[0;32m\]\u\[\033[0;36m\] @ \[\033[0;36m\]\h \w\[\033[0;32m\]$(__git_ps1)\n\[\033[0;32m\]└─\[\033[0m\033[0;32m\] \$\[\033[0m\033[0;32m\] ▶\[\033[0m\] '
```
Результат:
kadannr@wcrow:~/git/devops-netology/home-work/virt-homeworks(main)$

# Операции отмены - это одна из редких областей Git, гденеверными действиями можно необратимо удалить результатысвоей работы.
- Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит—внесите необходимые изменен:
  - git commit -m 'initial commit'
  - git add forgotten_file
  - git commit --amend
  - В итоге получится единый коммит—второй коммит заменит результаты первого.
- Команда git resetможет быть опасной если вызвать её с параметром--hard. В приведенном примере файл не был затронут, следовательнокоманда относительно безопасна.
  - продолжение в "Основы GIT" 17 слайд

# Ветки
`git branch [name]` -создание ветки
`gco [name] ` -переключение на ветку

# Рабочие команды, связки
`git commit -m 'name commit'` -закомитить
`git push -u [name репозитория] [name ветки]` -пропушить
`git reset --hard HEAD` -Отменить локальные изменения во всех файлах

----
# Менторинг по гиту
1. Ресурс для практики и обучения по гиту https://learngitbranching.js.org/?locale=ru_RU&NODEMO=
2. Репозиторий по которому покзывал https://github.com/FabitMobile
3. Ресурс по git flow https://danielkummer.github.io/git-flow-cheatsheet/index.ru_RU.html
	1. Главная особенность это ветка develop для разработки
	2. Одна release ветка
	3. Одна master (стабильный код) на которую вешаются теги с версиями 
4. Накатывать патчи это pull request (что бы шарить между репозиториями)
	1. git dif сформировать патч 
	2. git apply накатить в другой репозиторий
5. Версионность 0. 2. 1
                            |   |    |
                            |   |    патч<--------------------------------------------------------------------------------<-|
                            |   Минорная версия. Релиз новый +1, если баг то исправляем и добавляем в патч+1-|
                            Мажорная версия. +1 если потеряна обратная совместимость.  
6. Изменение в рамках одного коммита перенести куда угодно git cherry pick. Если черипикать это часто порождает конфликты.
7. Много разных коммитов сливаются лечше, чем много одних и тех же копии.

```
git commit
git branch new -создать ветку именем new
git checkout [name] -выбрать ветку (HEAD тоже переносится даже если указать конерктный комит вместо имени ветки)
git checkout -b [yourbranchname]  -создать новую ветку и переключиться на неё с помощью одной команды
git merge [bugFix]  - сделаем `merge` ветки `bugFix` в ветку `main`
	Так как ветка `bugFix` была предшественницей `main`, Git не делал ничего, только сдвинул `bugFix` на тот же коммит, где находится `main`. Поэтому Смерджим ветку `main` в ветку `bugFix`:
	 git checkout bugFix; git megre main
Второй способ объединения изменений в ветках - это _rebasing_. При ребейзе Git по сути копирует набор коммитов и переносит их в другое место.
Несмотря на то, что это звучит достаточно непонятно, преимущество `rebase` в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете `rebase`.
Так что `main^` означает "первый родитель ветки `main`" 
git checkout bugFix^ или git checkout HEAD~4 (на 4 родителя или сколько нужно вверх)
Перемещение ветки (branch forcing) Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции `-f`
git branch -f main HEAD~3   -Переместит (принудительно) ветку `main` на три родителя назад от `HEAD`

относительные ссылки 2
```

